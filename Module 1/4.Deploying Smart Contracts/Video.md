### Deploying Smart Contracts
![[Module 1/4.Deploying Smart Contracts/attachments/index.mp4]]
Transcript :
Model one lesson four. 

Deployment and execution of a smart contract. 

On completion of this lesson, 

you will be able to explain the smart contract deployment process, 

explore the artifacts generated by Remix compile process, 

discuss how these artifacts are used to deploy and interact with the smart contract. 

Let us start by getting into the smart contract deployment process. 

First, a smart contract solution is written in high-level language and compiled bytecode. 

An ABI is also generated for high-level language application. 

Example, Web Apps to interact with the binary smart contract. 

Recall that we discussed about etherium virtual machines in the last course. 

EVM provides execution environment for a smart contract bytecode. 

The smart contract requires an address for itself so 

that transaction can target it for invocation of its function. 

The contract address is generated by hashing the sender's account address and its nonce. 

A unique target account is reserved for smart contract creation and deployment. 

Target account zero. 

If a target's address is zero or null, 

it is meant for creating a new smart contract using its payload feed. 

The payload of a transaction contains the bytecode for the smart contract. 

This code is executed as a part of 

the transaction execution to instantiate the bytecode for the actual smart contract. 

Similar to how a constructor creates an object, 

the execution of a smart contract creation 

transaction results in the deployment of this smart contract code on the EVM. 

It is permanently stored in the EVM for future invocation. 

This transaction goes through all the regular verification 

and validation specified in the etherium blockchain protocol. 

Block creation, transaction confirmation by 

the full nodes deploys a the same contract on all the nodes. 

This provides consistent execution when 

the regular transaction with function messages are invoked on the smart contract. 

We have now explained the fundamental process of deployment of 

the smart contract but there are many other approaches for deploying this smart contract. 

They can be deployed from Remix IDE, 

another smart contract, a command line interface, 

another high-level language application or Web application. 

We're going to review the deployment using only the Remix IDE. 

Here is the complete process. 

You enter the smart contract code in the Remix IDE and compile. 

Remix generates several artifacts as discussed earlier and as shown in the picture. 

For the ease of deployment, 

Remix provides us with the Web3 deployment script which contains a bytecode. 

Application Binary Interface, ABI, and account detail. 

To deploy the smart contract, 

we could just execute the script. 

Once the deployment is done, 

the address is generated by hashing creator's account number and nonce. 

To interact with the smart contract, 

we'll use the smart contract address, 

ABI definition, and the function hashes. 

Summarizing. We learned the purpose of the smart contract and 

its critical role in transforming 

blockchain technology for enabling decentralize systems. 

We explored the structure and basic concepts of a smart contract through examples. 

We illustrated Remix, Web ID, 

for deploying and interacting with the smart contract. 

How do we design and program a smart contract? 

What are the elements of the solidity language 

so that we can drive the smart contract for our applications. 

We do that in the next module. 

Onto the next module, 

solidity language for smart contracts.