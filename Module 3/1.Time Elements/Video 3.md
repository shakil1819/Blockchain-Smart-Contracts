# Time Elements (Part 3)
---
![[Module 3/1.Time Elements/attachments/index_3.mp4]]

---


The newer variable added to ballot version 1R, annum for stage, and start time for timekeeping. Advancing the stages, will now depend on the time as specified in the state diagram. Here is a solution ballot version two, with stage and time elements added. This is a traditional solution with the conditions validated by programmatic approach, using if else statement. Now, we are moving to the next question of the ballot. Consider some opportunities for improvement. Validation of time and stage are done inside the function code, programmatically. Because of this, the transaction is executed and recorded on the block chain, irrespective of whether the validation fails or succeeds. Note the if else statement, at the top of the function code of the ballot's smart contract. Further, we ask these questions, is there any way to reject the transaction? In a way similar to how transactions were rejected, at the block chain protocol level, if they don't conform to the rules, that is, if the problem specific conditions are not met toward the transaction. In this case, the transaction will not be recorded on the block chain, wasting effort and space. If there is a way to separate the validation from the actual code that the function executes, is there a way to specify the problem specific rules and condition declaratively, so that they can be independently specified, as well as audited to assure that the smart contract does what it's supposed to do? Auditing of the Smart Contract is specially critical, since a smart contract is expected to be autonomous and permanent, once deployed. We address these issues in the next lesson that is built around problem-specific validation, by using function modifiers, required clause, revert and assert declarations.
