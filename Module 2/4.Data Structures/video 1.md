## Data Structures (Part 1) (BallotV1 Demo)

![[Module 2/4.Data Structures/attachments/index_2.mp4]]
```
On completion of this lesson you will be able to explain the syntax and usage of arrays, enum, struct data types of Solidity, illustrate the use of time units pre-defined in Solidity. We will begin with a simple smart contract as an example. We'll develop this example to illustrate the concepts for this lesson, struct, array, enum, and time units. Let us begin our analysis of the code base with a class diagram that visually represents an example, a modified version of the balanced smart contract specified in the Solidity documentation. The smart contract creator is the chairperson who gets a weight of two for her vote. Others get a weightage of one for their one vote. Each voter has to be registered first by the chairperson before they can vote. They can vote only once. A constant function is included to enable the client applications to call to obtain the result. The constant modifier of the function prevents it from changing any state of the smart contract. More importantly, this call comes directly to the smart contract not via a transaction, so it is not recorded in the blockchain. Since it does not change the state of the smart contract, there is no need. Struct is a composite data type of a group of related data that can be referenced by a single, meaningful, collective name. Individual elements of the struct can be accessed using the dot notation. Here is a struct in ballot smart contract representing a single voter with three attributes: weight of the vote, whether this person has voted boolean, and which proposal the person voted for. Voter struct is used to define a mapping of address. Another example for struct is a proposal data with just one element proposal number. We could also add another data to the struct, say proposal name that is of string type. Set of proposals is represented by an array of proposals. Let us now review the code on remix to check the usage of the struct and the arrays in the functions: constructor, register, vote, and winningProposals. Let's examine ballot version one. Once again, this is from Solidity documentation, and we have modified it somewhat, we have dropped one of the functions, and we have made it a simple one. It starts with the name of the ballot, and we have several data variables. One is a struct for the voters that has got the weightage of the vote, whether they voted or not, boolean and the vote itself, which proposal they vote it to. Then we have a structure proposal that has got the vote count for each one of them. The proposal array maintains the votes for each one of the proposals. The chairperson address is specified by a state variable and there is a mapping from address to voter that is specified by the variable voters. There are several functions, even though we dropped one of them, there are a couple of functions there to note. One is a function ballot which is a constructor, and then I have a register where that chairperson registers the voter and the person or the people who registered vote for it, vote for the proposals that are there and finally, there's a function winningProposal that can be called by the application. It doesn't come through a transaction. This will determine the winningProposal and it can be obtained by a client application. Let's run it and see. You can see that there are several conditions specified, and all the code is available inside the function. We'll not go into the details, but well, let's compile. We know, we understand the meaning of voting and deciding the proposal that wins. Let's compile and run. I'm going to go into JavaScript VM, and let's wait for a few minutes so that all the addresses are generated. These are the addresses that are available to you, and we will be using several of them. For the sake of demo, I'm just going to use one of them as a chairman, as you can see the ca, the one that start with ca. 0x states that there's a hexadecimal address, ca, the one that starts with ca3 is the chairperson. I'm just going to use just one other person for the sake of demo. But if you want to try it on your own, you can try any of these addresses as other people who may be interested in voting. You can try it at your leisure. So, let's create the smart contract. But in this case, when you're creating a smart contract you have to tell how many proposals are there since the constructor requires more than certain number of proposals. So, I'm just going to say three for the sake of simplicity. This is the chairperson. Chairperson is going to create the smart contract, and I did that. Here we have a simple interface since we had just three functions, and these functions are available in the web interface for us to use. First, I'm just going to simply press the winningProposal. Remember, winningProposals shouldn't show anything or shouldn't be displaying anything, should not be executing at all when nobody has voted, nobody has registered. But we're going to click on the winningProposal, and it shows it as zero. This is an error or a issue with the design that we have right now. Let's move on. So, I'm going to register one person and start voting here. So, in order to register you have to be the chairperson here. I'm going to go into the other person to address. This is the person, other voter and I'm going to copy the address of this person and put it in here. Addresses have to be within quotes and remix, so I'm just going to put it within quotes. These are all big numbers because they are 256 bits and I got to go back to the chairperson because only the chairperson can register. So I'm issuing this register from the chairperson's address, and this transaction goes from the chairperson to register this person. So, I'm going to register that person. One person has been registered. Now, let's vote. We have one chairperson and one voter. Just for the sake of understanding the balloting process, we are going to use only these two people. I'm going to vote for, let's say the chairperson wants to vote for the proposal number 01 or two. The chairperson votes were two. So this is the chairperson, the chairperson is initiating the vote transaction and number two is a parameter, the chairperson is voting for two. I'm going to press, and that's going through. You can see all the transaction going through here. Then I'm changing the address of the originator of the message to the next person who has registered. Then I'm going to say, "Okay, the voter who is not a chairperson is voting for one." So, understand what happened here. The chairperson voted for two. The regular voter voted for one and we want to find out the winningProposal. Remember, chairperson has a weightage of two. So obviously, it has to be two. So you can see the winningProposal is two because the chairperson, even though there was only one vote weightage was two and the winningProposal was two. So that is a very simple demo of the ballot contract that is given in the Solidity, a documentation, and we modified it somewhat by dropping a function. But we will take this base contract and improve on it by adding enums, stages, time, require, modifiers, and other kinds of check modifiers and other kinds of assertions so that it is a robust solution. On Remix IDE, you can save the list of transactions and view it to explain the sequence of operation. Here is a sample transaction. Can you guess what is wrong with this transaction? The transaction did execute consumed gas, but did not provide the result expected because it was from account two. Remember, nobody except the chairperson account zero can register. It has to be from account zero. We made a mistake in not selecting that right from address for registering. Check out the other correct transaction to understand this further.
```
