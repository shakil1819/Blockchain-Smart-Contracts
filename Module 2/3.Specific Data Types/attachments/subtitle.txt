On completion of this lesson, you will be able to explain important data structures of Solidity: address, mapping and message; explain Solidity events that logs events and pushes data to an application level listener. Address is a special Solidity define composite data type. It can hold a 20-byte ethereum address. Recall address is a reference address to access a smart contract. Address data structure also contains the balance of the account in Wei. It also supports a function transfer, to transfer a value to a specific address. Mapping is a very versatile data structure that is similar to a key value store, it also can be thought of as a hash table. The key is typically a secure hash of a simple Solidity data type such as address and the value in key-value pair can be any arbitrary type. Here we illustrate the idea of mapping with two examples. We can use phone number to name mapping. That's a common utility function on our phone system. As a second example, you can have a struct of all customer data and can use mapping to map an account address to customer data as shown. Let's now transition to message. Message is a complex data type specific to smart contract. It represents the call that can be used to invoke a function of a smart contract. It supports many attributes of which we are interested in two of them now. You can always look up other message details in the Solidity documentation, msg.sender that holds the address of the sender, msg.value that has the value in Wei sent by the sender. Now, you can write statements that verify and validate the address and the amount to make sure that the application specifics are met. Let's use these data structures and mint some money. Let's look at the smart contract for coin as specified in Solidity documentation. Recall, we always start with the design, say a class diagram whether we are analyzing a program or coding an application. Here is a class diagram for coin contract. Also make a note of the statements for, if-else assignment. Coin uses the two Solidity features address and mapping. Address holds the 20-byte ethereum address. Recall, address is the base for a smart contract. Let's review this code in Remix IDE. The next contract that we're going to look at is the coin. I created this under Minter.sol. The name of the contract is Coin and this is also from the Solidity documentation, and we have here one state variable, public minter. You can see that it has a data type of address that is Solidity specific. They are also illustrating the mapping function here mapping table where address is used to map on to the balances that we have. It also illustrates the event, an event has been defined as sent with three parameters: from whom the money was sent, to what address the money was sent, and the amount of money that was sent. We have the constructor where the message sender or the person who's creating this contract is defined as the minter and message sender. We're also illustrating the use of message and the sender data of the message and initializing the minter public data that we have in this contract. Next comes the function mint, where the coins are minted and in this case, only the sender, only the minter should be able to mint the coins. Only the owner of the smart contract should be able to mint the coin. So, I have here a simple command that tests the condition that whoever is the message sender for mint, is indeed the minter who created this contract. At this time, I'm going to close this bidder, we don't need that anymore. Once that is so, once a mint is requested by the owner of the contract and I mint those newly created coins and add to the receiver whose address was sent as a parameter. Finally, I have a send function where the coins created can be sent to a specific address. You specify the address of the receiver and the amount to be sent as a parameter and this is also a public function as you can see. If the balance of the sender of this message is less than the amount to be transferred, the function is returned. This is not completed. Otherwise, the balance of the sender is decremented, balance of the receiver is incremented. There is also an event log as what happened here? The sent is the event and it is pushed, it is logged with message sender and the receiver is the coin and the amount has three parameters. Three is the maximum number of parameters that is allowed for an event, recall that from our lesson, okay. This invokes that event and that gets logged.